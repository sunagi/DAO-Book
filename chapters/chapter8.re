= ブロックチェーンの技術
== ゼロ知識証明

ゼロ知識証明とは「自分だけが知っている秘密の情報を他人に伝えることなくそれが本当であると証明するもの」です。例えば、あなたがwebサイトにログインするためのパスワードを知っているけれどそのパスワードをwebサイトに入力することなくログインしたいとします。そのような時にゼロ知識証明は活用でき、あなたはパスワードを入力せずに代わりにパスワードを知っていることを何らかの手段でwebサイトに伝えることでログインを実現します。また、他の例でいうとあなたが不動産屋からアパートを借りたいとします。その際に不動産屋はあなたの年収がちゃんとあるのかを知りたいはずです。しかしあなたは自分のプライベートな情報を誰かに伝えたくないかもしれません。その時にゼロ知識証明を使えば、あなたの所得や年収が不動産屋が条件として求めている所得の範囲にあるかを、あなたの所得を明かすことなく証明できます。このように、ゼロ知識証明は人のプライバシーを守ったり、そのことが本当であるかどうか検証するために使われます。イーサリアムが出している記事によると、3つの基準が説明されています。証明者というのは自分があるお題について真実を知っていると主張している人です。検証者は証明者が本当にあるお題について知っているのかチェックする人です。

==== ゼロ知識証明の基準

 * 完全性: 正しいinputであれば常にtrueを返す。そうしたら他の内在するステートメントもtrueになり、証明者と検証者が正直に行動すれば、証明は受け入れられる。証明者と検証者がその方法にきちんと従ったら、いつも正しくその証明方法が動作しなくてはいけません。
 * 健全性: 嘘のinputを与えて、検証者をだますことができない。証明者が本当はあるお題について何も知らないのに、検証者に「証明者は本当のことを知っている」と騙せないこと
 * ゼロ知識(無知であること): 検証者はそれが事実であるか証明するために、それについて何も知らなくて良い。これにより検証者が証明から、証明する対象の情報を導くことを防ぐことにもなる

ゼロ知識証明には対話型と非対話型と呼ばれる2種類があります。対話型は何回も証明者と検証者が会話することで、検証者は証明者があるお題について知っていると納得してもらう方法です。具体例として太郎が赤と青のボールを見分けられるかの証明を考えてみましょう。あなたは右手に赤いボールを持っていて、左手に青のボールを持っています。次にあなたはボールを入れ替えるか入れ替えないかを選択します。そして太郎に手を見せてどっちの手に赤いボールがあるかを答えてもらいます。太郎が色を識別できるなら毎回正解するはずです。これが対話型の証明です。しかし、毎回証明者と検証者がやり取りをしなくてはいけません。そこで、検証者が1回しかチェックしなくていいようにと改善されたのが非対話型のゼロ知識証明です。ブロックチェーンでは全てのデータの状態はトランザクションに紐づけられ、誰でもそのデータをみることができます。そのため、プライベートな情報をブロックチェーンに書き込んでしまうとそのチェーンがなくならない限り一生データが残ってしまいます。つまり、ユーザーのプライバシーに対して弱いと言えます。現在だと自分の国籍を証明するためにパスポートを見せることが求めらると思います。しかしそれだとプライバシーを晒すため、そのような情報を晒すことなく解決する方法として分散型アイデンティティ（Decentralized Identity; DID）が提案されています。

== 分散型アイデンティティ（Decentralized Identity; DID）

2022年8月に Web 技術の標準化団体である World Wide Web Consortium（W3C）において分散型識別子（Decentralized Identifiers; DIDs）が標準化されました。巷では分散型アイデンティティ管理や自己主権型アイデンティティへの応用などが期待されており、今非常にホットな技術要素の一つです。DID は、識別子の一種です。今、非常に注目されていることもあり、場によっては DID が何か特別なアプリケーションであるかのように語られる向きがあるのですが、名前が表している通り、DID は単に識別子であり、それ以上でもそれ以下でもありません。したがって、通常のアプリケーション開発における識別子と同様にユースケースに応じて使い分ける必要がありますし、周辺技術といかに組み合わせるかが大事になります。アプリケーション開発に明るくない方向けに簡単に説明すると、識別子とは、「ある実体（エンティティ）の集合の中の、特定の要素（元）を一意に特定する属性の集合」を意味します。具体的に、皆さんが普段触れるであろう識別子には、以下のようなものがあります。

==== 識別子の例

 * X（旧 Twitter）や Instagram などのユーザ・アカウントを識別する「ハンドル名」
 * Web 空間上の資源（Web サイトや画像など）を識別する「Uniform Resource Identifier（URI）」
 * コンピュータ・ネットワーク上に接続する端末を識別する「IP アドレス」や「MAC アドレス」
 * リレーショナル・データベースのテーブル内においてレコードを識別する「プライマリ・キー」
 * 日本国内に居住し行政サービスを受けている自然人を識別する「マイナンバー（個人番号）」
 * 会社や学校内で個々の社員・学生を識別する「社員番号」や「学籍番号」
 * 世界中で一意な識別子を提供することを目指している「Universally Unique Identifier（UUID）」

ご覧の通り、識別子はサイバー空間上はおろか、フィジカル空間上でもよく使われる非常に大切なものであることがわかります。万が一この識別子が指す対象（主体、Subject とも言われます）が複数存在してしまった場合に起こることを想像してみてください。例えば、Web サイトにアクセスするたびに違う内容が表示されたり、会社の業績や学校の講義での評価が正確になされなかったり、非常に困ったことになります。SNS のハンドル名は、SNS のユーザ同士が個人のインターネット空間上のアイデンティティを識別する立派な識別子です。これが自分の意図しないままに勝手に変えられてしまうと、連絡が取れなくなったり、本人であるかの確認が困難になったりし、実際の生活でも大なり小なり様々な支障をきたします。仕様書に登場する DID を構成する要素は 6 つです。DID、DID Subject、DID URL、DID Document、DID Controller、そして Verifiable Data Registry です。それぞれの要素の関係を表した図を示します。これは標準文書中の Figure 2 を引用したものです。これらの 6 つの要素やその他様々な制約などを含めて定義し、まとまった1 つの実装として動くものを DID Method と言います。DID は名寄せのリスク対策など、プライバシやセキュリティに関してかなり考慮された設計となっています。DID の標準はあくまで抽象的なデータモデルやアーキテクチャを定義しているだけであり、一概にこうであるといえるものではありません。 DID Method に依ってプライバシリスクや集権性などの特性も様々です。決してあらゆる課題を解決する銀の弾丸のようなものは存在しないので、DID 自体の特性や Method 毎に異なる特性をきちんと理解し、ユースケースや活用する周辺技術に応じて、そもそも DID を用いるか否か、用いるならばどの Method を使うのかを慎重に検討する必要があります。

== Next.js（App Router）でWeb3.0アプリ開発

==== Web3.0でNext.jsが人気の理由

 * サーバーサイドレンダリング（SSR）：Next.jsはSSR（サーバーサイドレンダリング）をサポートしており、これにより、初期読み込みの高速化やSEOの向上が可能です。Web3のアプリケーションにおいては特に、ブロックチェーン上のデータを取得して表示する必要がある場合、SSRは非常に有用です。
 * 静的サイト生成（SSG）：Next.jsはSSGもサポートしています。SSGは、事前にページを生成し、静的なファイルとして提供することで、パフォーマンスを向上させます。Web3のアプリケーションでは、ブロックチェーン上のデータが頻繁に変化する場合でも、SSGを使用して静的なコンテンツを提供することができます。
 * ルーティングと状態管理：Next.jsは、ルーティング機能と状態管理を簡単に実装できる機能を提供しています。Web3のアプリケーションでは、複数の画面や状態の管理が必要な場合があります。Next.jsのルーティング機能と状態管理のツールセットは、このような要件に対応するのに役立ちます。
 * モジュールの管理：Next.jsは、npmやyarnを介してモジュールを管理するための便利なツールを提供します。Web3開発では、Web3ライブラリや関連するパッケージが多数準備されています。Next.jsのモジュール管理機能により、依存関係の解決やパッケージのバージョン管理が容易になります。

Web3.0アプリの開発はまずスマートコントラクトの作成から始まります。Solidityなどの言語を用いて開発し、Alchemyなどのプロバイダーにデプロイします。このステップはアプリの基礎となるため、非常に重要です。次に、フロントエンドの開発に移ります。ここではNext.jsなどを使用して画面を開発し、ライブラリ（例えばThirdweb.js）を使ってウォレットやプロバイダーへの接続を行います。しかし、App Routerでウォレットを接続するコードサンプルはほとんどなく、Thirdweb.jsの公式サイトでさえ、Pages Routerの例しか提供していません。この問題を解決するために、RainbowKitの使用を提案します。RainbowKitはWeb3.0アプリ向けのReactライブラリで、ウォレット接続機能を簡単に実装できます。デフォルトのウォレットボタンのカスタマイズやどのウォレットを表示するかの設定も可能です。RainbowKitは使いやすく、柔軟性が高いため、さまざまなWeb3.0プロジェクトで効果的に活用できるでしょう。Next.js はWeb3.0の開発と非常に親和性の高いフロントエンドフレームワークですが、現在も開発が活発に行われており、これまで使ってきたWeb3.0ライブラリでは対応できないこともあります。